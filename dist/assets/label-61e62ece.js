import{d as ht}from"./pinia-71cafef5.js";import{D as L}from"./decimal.js-d133ee8e.js";import"./tiff.js-f0b72392.js";import{b as W}from"./@vue-19632928.js";const wt=(r,o)=>{const a=new L(r),i=new L(o);return a.plus(i).toString()},X=(r,o)=>{const a=new L(r),i=new L(o);return a.minus(i).toString()},g=(r,o)=>{const a=new L(r),i=new L(o);return a.times(i).toString()},p=(r,o)=>{const a=new L(r),i=new L(o);return a.dividedBy(i).toString()},gt=r=>{const o=r.split(".");return o.length>1?o[o.length-1]:""},j=new Map,mt=async r=>{const o=gt(r);if(console.log("imgHandler",r,o),j.has(r))return j.get(r);let a=r;return o&&(o==="tif"||o==="tiff")&&(a=await new Promise((i,u)=>{const m=new XMLHttpRequest;m.open("GET",r,!0),m.responseType="arraybuffer",m.onload=function(){const B=new Tiff({buffer:m.response}).toCanvas().toDataURL();i(B)},m.onerror=function(){u(r)},m.send()}),j.set(r,a)),a},Mt=()=>{console.log("clearUrlCache",j);for(const r of j.values())URL.revokeObjectURL(r);j.clear()},Nt=ht("label",()=>{const r=W([]),o=W(),a=W([]),i=W(0),u=W([]),m=W(0),b=W(0),S=W(!1),B=W(!1),_=W(0),C=e=>{var n;i.value=0,a.value=e,u.value=((n=a.value)==null?void 0:n.map(t=>({isActive:!1,name:t.name,src:t.url,label:[]})))??[]},Y=e=>{a.value.length!==0&&(i.value+=e?1:-1,i.value<0?i.value=a.value.length<Math.abs(i.value)?0:a.value.length+i.value:i.value>=a.value.length&&(i.value=a.value.length===0?0:i.value%a.value.length))},K=e=>{for(let n=0;n<a.value.length;n++)if(a.value[n].path===e.path){i.value=n;break}},Q=e=>{for(let n=0;n<a.value.length;n++)if(a.value[n].path===e.path&&n===i.value)return!0;return!1},Z=(e,n)=>{const t={name:e,color:n};!t||r.value.find(s=>s.name===e)||(r.value.push(t),o.value=t)},tt=e=>{r.value=r.value.filter(n=>n.name!==e),o.value=void 0;for(const n of r.value)o.value=n;for(const n of u.value)n.label=n.label.filter(t=>t.attrs.label!==e)},et=()=>{r.value=[],o.value=void 0},nt=async e=>o.value=e,ot=async(e,n)=>{for(const t of r.value)if(t.name===e){t.color=n;break}for(let t=0;t<u.value.length;t++)for(let s=0;s<u.value[t].label.length;s++){const d=u.value[t].label[s];d.attrs.label===e&&(d.attrs.fill=n,d.attrs.stroke=n,u.value[t].label[s]=d)}},at=(e,n)=>{n===void 0&&(n=i.value),u.value[n].label=e},I=e=>e<0?0:e>1?1:e??0,D=e=>e.map(n=>{const{className:t,attrs:s,children:d}=n,{width:c,height:w,scaleX:l=1,scaleY:f=1,label:h}=s,y=(s==null?void 0:s.x)??0,v=(s==null?void 0:s.y)??0;if(t==="Rect"){const x=+g(c,l),H=+g(w,f),P=+p(y,m.value),A=+X(1,+p(y+x,m.value)),E=+p(v,b.value),R=+X(1,+p(v+H,b.value)),T=[y,v,y+x,v,y+x,v+H,y,v+H];for(let M=0;M<T.length;M++)M%2===0?T[M]=I(Number(p(T[M],m.value))):T[M]=I(Number(p(T[M],b.value)));return{label:h,percentage:{top_percentage:E,bottom_percentage:R,left_percentage:P,right_percentage:A},points:T}}const N=d==null?void 0:d.find(x=>x.className==="Line");return N?{label:h,points:N.attrs.points.map((x,H)=>H%2===0?I(Number(p(x+y,m.value))):I(Number(p(x+v,b.value))))}:{name:"",label:"",points:[]}}).filter(n=>n.points.length>0),st=async()=>{const e=await Promise.all(u.value.map(n=>{const{src:t,label:s,name:d,isActive:c}=n;return new Promise(w=>{if(t.endsWith(".tiff")||t.endsWith(".tif")){const l=new XMLHttpRequest;l.open("GET",t),l.responseType="arraybuffer",l.onload=f=>{const h=l.response,y=new Tiff({buffer:h}),v=y.width(),N=y.height();w({name:d,url:t,isActive:c,originWidth:v,originHeight:N,labels:D(s)})},l.onerror=f=>{console.error("Error loading image:",f)},l.send()}else{const l=new Image;l.onload=()=>{const f=l.width,h=l.height;w({name:d,url:t,isActive:c,originWidth:f,originHeight:h,labels:D(s)})},l.onerror=f=>{console.error("Error loading image:",f)},l.src=t}})}));return console.log("exportLabelFiles ===",e),e},rt=({name:e,label:n,points:t})=>{if(!(!m.value||!b.value))switch(e){case"rect":return it(n,t);case"poly":return lt(n,t);default:return}},it=(e,n)=>{if(Object.keys(n).length===0)return;const t=+g(n[0],m.value),s=+g(n[1],b.value),d=+g(Math.abs(+X(n[0],n[2])),m.value),c=+g(Math.abs(+X(n[1],n[5])),b.value);return{label:e,name:"rect",points:[+g(n[0],m.value),+g(n[1],b.value)],x:t,y:s,width:d,height:c}},lt=(e,n)=>{if(Object.keys(n).length!==0)return{label:e,name:"poly",points:[...n.map((t,s)=>s%2===0?+g(t,m.value):+g(t,b.value))],x:0,y:0,width:m.value,height:b.value}},U=async e=>{var v,N,x,H,P,A;const n=[],s=await(await fetch(e)).text(),c=new DOMParser().parseFromString(s,"text/xml"),w=c.getElementsByTagName("size")[0],l=((v=w.getElementsByTagName("width")[0].childNodes[0])==null?void 0:v.nodeValue)??"0",f=((N=w.getElementsByTagName("height")[0].childNodes[0])==null?void 0:N.nodeValue)??"0",h=c.getElementsByTagName("object");for(let E=0;E<h.length;E++){const R=h[E],T=R.getElementsByTagName("name")[0].childNodes[0].nodeValue,M=R.getElementsByTagName("bndbox")[0],V=((x=M.getElementsByTagName("xmin")[0].childNodes[0])==null?void 0:x.nodeValue)??"0",k=((H=M.getElementsByTagName("ymin")[0].childNodes[0])==null?void 0:H.nodeValue)??"0",O=((P=M.getElementsByTagName("xmax")[0].childNodes[0])==null?void 0:P.nodeValue)??"0",$=((A=M.getElementsByTagName("ymax")[0].childNodes[0])==null?void 0:A.nodeValue)??"0";n.push({name:T,xmin:V,ymin:k,xmax:O,ymax:$})}return n.map(E=>{const{name:R,xmin:T,ymin:M,xmax:V,ymax:k}=E,O=+p(+T,+l),$=+p(+M,+f),z=+p(+V,+l),q=+p(+k,+f);return{label:R??"",name:"rect",points:[O,$,z,$,z,q,O,q]}})},G=async e=>{const t=await(await fetch(e)).json(),{imageWidth:s,imageHeight:d,shapes:c}=t;return c.map(l=>{const{label:f,points:h}=l;console.log("points ===",h);let y=!1;try{y=h[0][0]===h[3][0]&&h[1][0]===h[2][0]&&h[0][1]===h[1][1]&&h[2][1]===h[3][1]}catch{y=!1}return y?{label:f,name:"rect",points:h.map(v=>{const N=+p(v[0],s),x=+p(v[1],d);return[N,x]}).flat()}:{label:f,name:"poly",points:h.map(v=>{const N=+p(v[0],s),x=+p(v[1],d);return[N,x]}).flat()}})},ct=async e=>(await(await fetch(e)).text()).split(`
`).map(c=>{const[w,l,f,h,y]=c.split(" ").map(parseFloat);return{label:w,name:"rect",points:[l,f,l+h,f,l,f+y,l+h,f+y]}}),ut=e=>e.map(t=>{const{points:s}=t;if(s[0]===s[6]&&s[1]===s[3]&&s[2]===s[4]&&s[5]===s[7])return{label:t.label,name:"rect",points:s};const c=[Math.min(...s.filter((w,l)=>l%2===0)),Math.min(...s.filter((w,l)=>l%2!==0)),Math.max(...s.filter((w,l)=>l%2===0)),Math.max(...s.filter((w,l)=>l%2!==0))];return{label:t.label,name:"rect",points:[c[0],c[1],c[2],c[1],c[2],c[3],c[0],c[3]]}}),J=e=>`
    <annotation>
      <folder>VOC</folder>
      <filename>${e.name}</filename>
      <path>${e.name}</path>
      <size>
        <width>${e.originWidth}</width>
        <height>${e.originHeight}</height>
        <depth>3</depth>
      </size>
      <segmented>0</segmented>
      ${e.labels.map(t=>`
      <object>
        <name>${t.label}</name>
        <pose>Unspecified</pose>
        <truncated>0</truncated>
        <difficult>0</difficult>
        <bndbox>
          <xmin>${Math.floor(+g(t.points[0],e.originWidth))}</xmin>
          <ymin>${Math.floor(+g(t.points[1],e.originHeight))}</ymin>
          <xmax>${Math.floor(+g(t.points[4],e.originWidth))}</xmax>
          <ymax>${Math.floor(+g(t.points[5],e.originHeight))}</ymax>
          </bndbox>
      </object>
      `).join("")}
    </annotation>
    `,F=e=>({version:"4.5.9",flags:{},imagePath:e.name,imageData:null,imageHeight:e.originHeight,imageWidth:e.originWidth,shapes:e.labels.map(t=>t.points[0]===t.points[6]&&t.points[1]===t.points[3]&&t.points[2]===t.points[4]&&t.points[5]===t.points[7]?{label:t.label,points:[[Math.floor(+g(t.points[0],e.originWidth)).toString(),Math.floor(+g(t.points[1],e.originHeight)).toString()],[Math.floor(+g(t.points[2],e.originWidth)).toString(),Math.floor(+g(t.points[3],e.originHeight)).toString()],[Math.floor(+g(t.points[4],e.originWidth)).toString(),Math.floor(+g(t.points[5],e.originHeight)).toString()],[Math.floor(+g(t.points[6],e.originWidth)).toString(),Math.floor(+g(t.points[7],e.originHeight)).toString()]],group_id:null,shape_type:"rectangle",flags:{}}:{label:t.label,points:t.points.map((d,c)=>c%2===0?[Math.floor(+g(d,e.originWidth)),Math.floor(+g(t.points[c+1],e.originHeight))]:null).filter(d=>d!==null),group_id:null,shape_type:"polygon",flags:{}})});return{imageWidth:m,imageHeight:b,imgs:a,currentImage:i,labels:r,currentLabel:o,labelImgs:u,resetImage:C,changeImage:Y,setCurrentImage:K,isCurrentImage:Q,addLabel:Z,removeLabel:tt,resetLabel:et,selectLabel:nt,recordLabel:at,changeLabelColor:ot,processLabels:D,exportLabelFiles:st,handleLabelsGraphic:rt,handleXMLtoLabels:U,handleJSONtoLabels:G,handleTXTtoLabels:ct,handleLabelsToXML:J,handleLabelsToRectLabel:ut,handleLabelsToJSON:F,handleJSONtoXML:e=>G(e).then(n=>n.map(t=>J(t))),handleXMLtoJSON:e=>U(e).then(n=>n.map(t=>F(t))),controlLock:S,loading:B,downloadProgress:_}}),Tt=[{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:1}],Wt=r=>{const o=r.flatMap(({x:i,y:u})=>[i,u]);return{name:o[0]===o[6]&&o[1]===o[3]&&o[2]===o[4]&&o[5]===o[7]?"rect":"poly",label:null,points:o}},St=r=>{const o=r.points,a=[];for(let i=0;i<o.length;i+=2)a.push({x:o[i],y:o[i+1]});return a},Ht=r=>{const o=r.points,[a,i,u,m]=[o[0],o[1],o[4],o[5]];return{x1:a,y1:i,x2:u,y2:m}},dt=async r=>new Promise((o,a)=>{const i=new Image;i.onload=function(){o(i)},i.onerror=function(){a(new Error(`Failed to load image from ${r}`))},mt(r).then(u=>{i.src=u??""})}),Lt=async(r,o)=>{const a=await dt(r);return(()=>new Promise(u=>{var m;if((m=o.value)!=null&&m.clientWidth){const b=+p(a.width,a.height),S=Math.min(o.value.clientWidth,a.width<400?400:a.width),B=+p(S,b);u({width:S,height:B})}else{const b=setInterval(()=>{var S;if((S=o.value)!=null&&S.clientWidth){clearInterval(b);const B=+p(a.width,a.height),_=Math.min(o.value.clientWidth,a.width<400?400:a.width),C=+p(_,B);u({width:_,height:C})}},100)}}))()};export{Tt as a,wt as b,Mt as c,p as d,gt as e,Ht as f,Lt as g,Wt as h,mt as i,St as j,g as m,X as s,Nt as u};
